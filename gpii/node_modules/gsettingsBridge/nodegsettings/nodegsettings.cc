/*
 * GPII Node.js GSettings Bridge
 *
 * Copyright 2012 Steven Githens
 * Copyright 2015 Raising the Floor
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/linux/blob/master/LICENSE.txt
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 */


#include <nan.h>
#include <gio/gio.h>

NAN_METHOD(get_gsetting_keys) {
  GSettings *settings;
  GSettingsSchema *gschema;
  gchar **keys;
  gint i;
  gint size = 0;
  v8::Local<v8::String> schema = info[0].As<v8::String>();
  settings = g_settings_new(*v8::String::Utf8Value(schema));

  g_object_get(settings, "settings-schema", &gschema, NULL);
  keys = g_settings_schema_list_keys(gschema);

  for (i = 0; keys[i]; i++) {
    size++; // Figure out how to do this in 1 loop
  }
  v8::Local<v8::Array> togo = Nan::New<v8::Array>(size);
  for (i = 0; keys[i]; i++) {
    togo->Set(i, Nan::Encode(keys[i], strlen(keys[i]), Nan::UTF8));
  }

  g_free(keys);
  g_settings_schema_unref(gschema);
  g_object_unref(settings);

  info.GetReturnValue().Set(togo);
}

///* Should take schema and key */
NAN_METHOD(get_gsetting) {
  GSettings *settings;
  v8::Local<v8::String> schema = info[0].As<v8::String>();
  v8::Local<v8::String> key = info[1].As<v8::String>();
  settings = g_settings_new(*v8::String::Utf8Value(schema));
  GVariant* variant;
  const GVariantType* type;

  variant = g_settings_get_value(settings, *v8::String::Utf8Value(key));
  type = g_variant_get_type(variant);

  if (g_variant_type_equal(type,G_VARIANT_TYPE_DOUBLE)) {
    info.GetReturnValue().Set(Nan::New(g_variant_get_double(variant)));
  }
  else if (g_variant_type_equal(type,G_VARIANT_TYPE_INT32)) {
    info.GetReturnValue().Set(Nan::New(g_variant_get_int32(variant)));
  }
  else if (g_variant_type_equal(type,G_VARIANT_TYPE_STRING)) {
    info.GetReturnValue().Set(Nan::New(g_variant_get_string(variant,NULL)).ToLocalChecked());
  }
  else if (g_variant_type_equal(type,G_VARIANT_TYPE_BOOLEAN)) {
    info.GetReturnValue().Set(Nan::New<v8::Boolean>(g_variant_get_boolean(variant)));
  }
  else {
    g_print("The type is %s\n", g_variant_type_peek_string(type));
    Nan::ThrowError(Nan::New("Need to implement reading that value type").ToLocalChecked());
  }

  g_clear_object(&settings);
  g_variant_unref(variant);
}

///* Should take schema, key, and value */
NAN_METHOD(set_gsetting) {
  GSettings *settings;
  GVariant* variant;
  const GVariantType* type;
  v8::Local<v8::String> schema = info[0].As<v8::String>();
  v8::Local<v8::String> key = info[1].As<v8::String>();
  bool status = false;

  settings = g_settings_new(*v8::String::Utf8Value(schema));
  if (info[2]->IsBoolean()) {
    status = g_settings_set_boolean(settings, *v8::String::Utf8Value(key),
                                    info[2]->BooleanValue());
  }
  else if (info[2]->IsNumber()) {
    variant = g_settings_get_value(settings, *v8::String::Utf8Value(key));
    type = g_variant_get_type(variant);
    if (g_variant_type_equal(type,G_VARIANT_TYPE_DOUBLE)) {
      status = g_settings_set_double(settings, *v8::String::Utf8Value(key),
                                     info[2]->ToNumber()->Value());
    }
    else if (g_variant_type_equal(type,G_VARIANT_TYPE_INT32)) {
      status = g_settings_set_int(settings, *v8::String::Utf8Value(key),
                                  info[2]->ToInt32()->Value());
    }
    else {
      g_print("The type is %s\n", g_variant_type_peek_string(type));
      Nan::ThrowError(Nan::New("We haven't implemented this number type yet!").ToLocalChecked());
    }
    g_variant_unref(variant);
  }
  else if (info[2]->IsString()) {
    v8::Local<v8::String> val = info[2].As<v8::String>();
    variant = g_settings_get_value(settings, *v8::String::Utf8Value(key));
    type = g_variant_get_type(variant);
    status = g_settings_set_string(settings, *v8::String::Utf8Value(key),
                                   *v8::String::Utf8Value(val));
    g_variant_unref(variant);
  }
  else {
    Nan::ThrowError(Nan::New("We haven't implemented this type yet!").ToLocalChecked());
  }
  g_settings_sync();
  g_clear_object(&settings);

  info.GetReturnValue().Set(Nan::New<v8::Boolean>(status));
}

NAN_MODULE_INIT(init) {
  Nan::Set(target, Nan::New<v8::String>("set_gsetting").ToLocalChecked(),
      Nan::GetFunction(Nan::New<v8::FunctionTemplate>(set_gsetting)).ToLocalChecked());
  Nan::Set(target, Nan::New<v8::String>("get_gsetting").ToLocalChecked(),
      Nan::GetFunction(Nan::New<v8::FunctionTemplate>(get_gsetting)).ToLocalChecked());
  Nan::Set(target, Nan::New<v8::String>("get_gsetting_keys").ToLocalChecked(),
      Nan::GetFunction(Nan::New<v8::FunctionTemplate>(get_gsetting_keys)).ToLocalChecked());
}

NODE_MODULE(nodegsettings, init)
