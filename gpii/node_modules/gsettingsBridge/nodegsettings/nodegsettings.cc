/*
 * GPII Node.js GSettings Bridge
 *
 * Copyright 2012 Steven Githens
 * Copyright 2015 Raising the Floor
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */


#include <nan.h>
#include <gio/gio.h>

using namespace v8;
using v8::FunctionTemplate;
using v8::Handle;
using v8::Isolate;
using v8::Object;
using v8::String;
using Nan::GetFunction;
using Nan::New;
using Nan::Set;
using Nan::ThrowError;

NAN_METHOD(get_gsetting_keys) {
  Isolate *isolate = info.GetIsolate();
  GSettings *settings;
  gchar ** keys;
  gint i;
  gint size = 0;
  Local<String> schema = info[0].As<String>();
  settings = g_settings_new(*String::Utf8Value(schema));
  keys = g_settings_list_keys(settings);

  for (i = 0; keys[i]; i++) {
    size++; // Figure out how to do this in 1 loop
  }
  Handle<Array> togo = Array::New(isolate, size);
  for (i = 0; keys[i]; i++) {
    togo->Set(i,String::NewFromUtf8(isolate, keys[i]));
  }

  g_free(keys);
  g_clear_object(&settings);

  info.GetReturnValue().Set(togo);
}

///* Should take schema and key */
NAN_METHOD(get_gsetting) {
  Isolate *isolate = info.GetIsolate();
  GSettings *settings;
  Local<String> schema = info[0].As<String>();
  Local<String> key = info[1].As<String>();
  settings = g_settings_new(*String::Utf8Value(schema));
  GVariant* variant;
  const GVariantType* type;

  variant = g_settings_get_value(settings, *String::Utf8Value(key));
  type = g_variant_get_type(variant);

  if (g_variant_type_equal(type,G_VARIANT_TYPE_DOUBLE)) {
    info.GetReturnValue().Set(Number::New(isolate, g_variant_get_double(variant)));
  }
  else if (g_variant_type_equal(type,G_VARIANT_TYPE_INT32)) {
    info.GetReturnValue().Set(Int32::New(isolate, g_variant_get_int32(variant)));
  }
  else if (g_variant_type_equal(type,G_VARIANT_TYPE_STRING)) {
    info.GetReturnValue().Set(String::NewFromUtf8(isolate, g_variant_get_string(variant,NULL)));
  }
  else if (g_variant_type_equal(type,G_VARIANT_TYPE_BOOLEAN)) {
    info.GetReturnValue().Set(Boolean::New(isolate, g_variant_get_boolean(variant)));
  }
  else {
    g_print("The type is %s\n", g_variant_type_peek_string(type));
    ThrowError(String::NewFromUtf8(isolate, "Need to implement reading that value type"));
    info.GetReturnValue().Set(Undefined(isolate));
  }

  g_clear_object(&settings);
  g_variant_unref(variant);
}

///* Should take schema, key, and value */
NAN_METHOD(set_gsetting) {
  Isolate *isolate = info.GetIsolate();
  GSettings *settings;
  GVariant* variant;
  const GVariantType* type;
  Local<String> schema = info[0].As<String>();
  Local<String> key = info[1].As<String>();
  bool status = false;

  settings = g_settings_new(*String::Utf8Value(schema));
  if (info[2]->IsBoolean()) {
    status = g_settings_set_boolean(settings, *String::Utf8Value(key), info[2]->BooleanValue());
  }
  else if (info[2]->IsNumber()) {
    variant = g_settings_get_value(settings, *String::Utf8Value(key));
    type = g_variant_get_type(variant);
    if (g_variant_type_equal(type,G_VARIANT_TYPE_DOUBLE)) {
      status = g_settings_set_double(settings, *String::Utf8Value(key), info[2]->ToNumber()->Value());
    }
    else if (g_variant_type_equal(type,G_VARIANT_TYPE_INT32)) {
      status = g_settings_set_int(settings, *String::Utf8Value(key), info[2]->ToInt32()->Value());
    }
    else {
      g_print("The type is %s\n", g_variant_type_peek_string(type));
      ThrowError(String::NewFromUtf8(isolate, "We haven't implemented this number type yet!"));
    }
    g_variant_unref(variant);
  }
  else if (info[2]->IsString()) {
    Local<String> val = info[2].As<String>();
    variant = g_settings_get_value(settings, *String::Utf8Value(key));
    type = g_variant_get_type(variant);
    status = g_settings_set_string(settings, *String::Utf8Value(key), *String::Utf8Value(val));
    g_variant_unref(variant);
  }
  else {
    ThrowError(String::NewFromUtf8(isolate, "We haven't implemented this type yet!"));
  }
  g_settings_sync();
  g_clear_object(&settings);

  info.GetReturnValue().Set(Boolean::New(isolate, status));
}

NAN_MODULE_INIT(init) {
  Nan::Set(target, New<String>("set_gsetting").ToLocalChecked(),
      GetFunction(New<FunctionTemplate>(set_gsetting)).ToLocalChecked());
  Nan::Set(target, New<String>("get_gsetting").ToLocalChecked(),
      GetFunction(New<FunctionTemplate>(get_gsetting)).ToLocalChecked());
  Nan::Set(target, New<String>("get_gsetting_keys").ToLocalChecked(),
      GetFunction(New<FunctionTemplate>(get_gsetting_keys)).ToLocalChecked());
}

NODE_MODULE(nodegsettings, init)
