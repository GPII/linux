/*!
GPII Node.js find + search packages

Copyright 2013-2014 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt

Author:  Joseph Scheuhammer.
*/

/*
Command line: node findSearchPk.js <name>.
For example:  node findSearchPk.js orca

This takes a two step approach to determine whether the named software is
available on the system.  The first step involves using the linux 'find'
command to search for the given software.  The second step uses PackageKit's
search facility.

The find command is used to search the directories listed in the PATH
environment variable.  There are two outcomes:

1. The software is not found.  This is taken to mean that the software is not
installed on the system.

2. The software is found in one of the PATH directories.  This is taken to mean
that the software is installed.

In summary, the first step uses the find command to determine if the software
is installed.

For the first outcome, the process continues and uses the packagekit node
add-on's searchPackage(), with a filter that indicates to search for
not-installed packages.  The result will either report the repository from
which the software can be installed, or, that no repository contains the
software.  If found in a repository, the package id, version number, etc. is
returned.

In the second case, the add-on's searchFiles() function is used with the given
path, and fetches the information about the package for that path.  If that
fails to discover anything, the add-on's searchPackage() is used at least once,
and possibly twice.  The first attempt employs a filter that indicates to search
for installed packages.  If this search returns information about a package,
then no further action is taken.  But, if it returns nothing, then
searchPackage() is done a second time using an not-installed filter. That may
return what is available to install.

The end result is:
1. Package information as to what is installed on the system.
2. Package information as to what is available to be installed.
3. A combination of 1. and 2. if there is the package is installed, and there is
an update available for installation.
4. No package information.

Issues:
- when the find command finds the software, but PackageKit knows nothing about
it, it is impossible (?) to determine the version of the software:
- while many linux commands support a "--version" option*, the output is not
consistent:
-- the format of the version string is not standardized.
-- some commands write the version string to stdout; some to stderr.
-- some GUI applications require GTK (or some other toolkit) in order to launch.

*note:  the "--version" option is supposed to launch a a minimal convfiguration
of the software, report the version, and quit.

The end result of this script is an (array of) objects each containning a
package id, a version number, whether the package is installed, and the
associated repository.  This demo prints the package information of all
packages found.

*/

/* global require, process, console */

(function () {

    "use strict";

    var packagekit = require("./build/Release/nodepackagekit.node");

    var lookingFor = process.argv[2];

    // Record the files found by 'find', and possibly related packages.
    var whatFindFound = [];
    var packages = [];

    // Use package kit add-on to get version of the software.
    // - searchNotInstalled() is used when 'find' found nothing.
    // - searchInstalled() is used when 'find' found something.
    function searchNotInstalled() {
        packages = packagekit.searchPackage(lookingFor, "~installed;basename");
    }

    function searchInstalled() {
        packages = packagekit.searchFiles(whatFindFound);
        if (packages.length === 0)  {
            packages = packagekit.searchPackage(lookingFor, "installed;basename");
        }
    }

    // Handle 'find' on close event -- invoke packagekit.searchPackage().
    function onFindClose() {
        console.log("'find' found " +
                     (whatFindFound.length === 0 ? "nothing" : whatFindFound));

        if (whatFindFound.length === 0) {
            searchNotInstalled();
        }
        else {
            searchInstalled();
            if (packages.length === 0) {
                searchNotInstalled();
            }
        }
        if (packages.length > 0) {
            console.log(JSON.stringify(packages, null, " "));
        }
        else {
            console.log("No package found");
        }
    }

    function onFindStdout(data) {
        var found = data.toString().split("\n");
        found.forEach(function (value) {
            if (value.length > 0) {
                whatFindFound.push(value);
            }
        });
    }

    if (lookingFor !== undefined) {
        var findArgs = process.env.PATH.split(":");
        findArgs.push(process.env.HOME);
        findArgs.push("-name");
        findArgs.push(lookingFor);
        findArgs.push("-type");
        findArgs.push("f");  // only regular files.
        findArgs.push("-print");

        // Run 'find'
        var spawn = require("child_process").spawn,
            find  = spawn("find", findArgs);

        find.stdout.on("data", onFindStdout);

        find.on("close", onFindClose);

        find.on("error", function (err) {
            console.log("child process <err>: " + err);
        });
    }
}());
