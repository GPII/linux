/*
GPII Node.js PackageKit Bridge

Copyright 2012 Steven Githens
Copyright 2013 Emergya
Copyright 2013-2015 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/
#define I_KNOW_THE_PACKAGEKIT_GLIB2_API_IS_SUBJECT_TO_CHANGE 1

#include <nan.h>
#include <packagekit-glib2/packagekit.h>
#include <gio/gio.h>
#include <json-glib/json-glib.h>
#include <string>

using namespace v8;
using v8::FunctionTemplate;
using v8::Handle;
using v8::Object;
using v8::String;
using v8::Value;
using Nan::GetFunction;
using Nan::New;
using Nan::Set;
using Nan::ThrowError;

/* Set DEBUG to TRUE in order to see the transactions' progress
 * TODO: Allow switching DEBUG value from Node.js side
 */
static gboolean DEBUG = FALSE;

static gchar TAG[] = "[nodePackagekit]";

static std::basic_string<gchar>
utf8StringFromValue(Handle<Value> value)
{
    Local<String> string = value.As<String>();
    return (*String::Utf8Value(string));
}

static void
progressCallback(PkProgress *progress, PkProgressType type) {
  if (!DEBUG) return;
  PkStatusEnum status;
  gint percentage;
  gboolean allow_cancel;

  g_object_get(progress,
               "status", &status,
               "percentage", &percentage,
               "allow-cancel", &allow_cancel,
               NULL);

  if (type == PK_PROGRESS_TYPE_STATUS) {
    printf ("%s Transaction status: %s\n", TAG, pk_status_enum_to_string (status));
  } else if (type == PK_PROGRESS_TYPE_PERCENTAGE) {
    if (percentage > 0)
      printf ("%s Current percentage: %d%%\n", TAG, percentage);
  }
}

static PkBitfield
handleFiltersArgument (const Nan::FunctionCallbackInfo<v8::Value>& args, const int filterIndex) {
  std::basic_string<gchar> filters;

  if (args.Length() > filterIndex) {
    filters = utf8StringFromValue(args[filterIndex]);
  }
  else {
    filters = (gchar *) "none";
  }
  return pk_filter_bitfield_from_string (filters.c_str());
}

static Handle<Object>
makePac (PkPackage *package, Isolate *isolate) {
  Handle<Object> pac = Nan::New<Object>();

  pac->Set(String::NewFromUtf8 (isolate, "id"),
           String::NewFromUtf8 (isolate, pk_package_get_id (package)));

  pac->Set(String::NewFromUtf8 (isolate, "name"),
           String::NewFromUtf8 (isolate, pk_package_get_name (package)));

  pac->Set(String::NewFromUtf8 (isolate, "version"),
           String::NewFromUtf8 (isolate, pk_package_get_version (package)));

  pac->Set(String::NewFromUtf8 (isolate, "arch"),
           String::NewFromUtf8 (isolate, pk_package_get_arch (package)));

  pac->Set(String::NewFromUtf8 (isolate, "data"),
           String::NewFromUtf8 (isolate, pk_package_get_data (package)));

  return (pac);
}

/**
 * searchPackage:
 *
 * Should take as arguments:
 *   name:    Name of the package, aka: search criteria (str)
 *   filters: Filters for the search as a string, e.g. "~devel;basename".  See:
 *            http://www.packagekit.org/gtk-doc/introduction-ideas-filters.html
 *            Special case:  the "none" filter = installed or available.
 * Returns: Array of packages matching the search criteria
 */
NAN_METHOD(searchPackage) {
  Isolate *isolate = info.GetIsolate();
  PkClient *client = NULL;
  PkResults *pkResults = NULL;
  GPtrArray *array;
  PkPackageSack *sack = NULL;
  std::basic_string<gchar> name;
  PkBitfield filtersBitField;
  GError *err = NULL;
  Handle<Object> pac;
  Handle<Array> result;

  name = utf8StringFromValue(info[0]);
  gchar *names[sizeof(name)] = {&name[0]};

  filtersBitField = handleFiltersArgument (info, 1);

  client = pk_client_new();
  pkResults = pk_client_search_names (
    client, filtersBitField, names, NULL,
    (PkProgressCallback) progressCallback, NULL, &err
  );

  sack = pk_results_get_package_sack(pkResults);
  pk_package_sack_sort (sack, PK_PACKAGE_SACK_SORT_TYPE_NAME);
  array = pk_package_sack_get_array (sack);
  
  result = Array::New(isolate, array->len);
  for (unsigned int i=0; i<array->len; i++) {
    PkPackage *package = (PkPackage *) g_ptr_array_index(array, i);
    pac = makePac (package, isolate);
    result->Set (i, pac);
  }

  if (pkResults != NULL)
    g_object_unref (pkResults);
  if (sack != NULL)
    g_object_unref (sack);
  if (client != NULL)
    g_object_unref (client);
  if (array != NULL)
    g_ptr_array_unref(array);
  if (err != NULL)
    g_clear_error(&err);

  info.GetReturnValue().Set(result);
}

/**
 * searchFiles:
 *
 * Should take as arguments:
 *   name:    Path name associated with package, e.g., "/usr/bin/orca".
 *   filters: Filters for the search as a string, e.g. "~devel;basename".  See:
 *            http://www.packagekit.org/gtk-doc/introduction-ideas-filters.html
 *            Special case:  the "none" filter = installed or available.
 * Returns: Array of packages matching the search criteria.
 */
NAN_METHOD(searchFiles) {
  Isolate *isolate = info.GetIsolate();
  PkClient *client = NULL;
  PkResults *pkResults = NULL;
  GPtrArray *array;
  PkPackageSack *sack = NULL;
  std::basic_string<gchar> pathName;
  PkBitfield filtersBitField;
  GError *err = NULL;
  Handle<Object> pac;
  Handle<Array> result;

  pathName = utf8StringFromValue (info[0]);
  gchar *pathNames[sizeof(pathName)] = {&pathName[0]};
  filtersBitField = handleFiltersArgument (info, 1);

  client = pk_client_new();
  pkResults = pk_client_search_files (
    client, filtersBitField, pathNames, NULL,
    (PkProgressCallback) progressCallback, NULL, &err
  );

  sack = pk_results_get_package_sack(pkResults);
  pk_package_sack_sort (sack, PK_PACKAGE_SACK_SORT_TYPE_NAME);
  array = pk_package_sack_get_array (sack);

  result = Array::New (isolate, array->len);
  for (unsigned int i=0; i<array->len; i++) {
    PkPackage *package = (PkPackage *) g_ptr_array_index(array, i);
    pac = makePac (package, isolate);
    result->Set (i,pac);
  }

  if (pkResults != NULL)
    g_object_unref (pkResults);
  if (sack != NULL)
    g_object_unref (sack);
  if (client != NULL)
    g_object_unref (client);
  if (array != NULL)
    g_ptr_array_unref(array);
  if (err != NULL)
    g_clear_error(&err);

  info.GetReturnValue().Set (result);
}

/**
 * getPackages:
 *
 * Should take as arguments:
 *   filters: Filters for list of packages to return, e.g. "installed" or
 *            "~installed", or "~devel;basename".
 *            See:
 *            http://www.packagekit.org/gtk-doc/introduction-ideas-filters.html
 *            Special case:  the "none" filter = installed or available, which
 *            means every possible package.  If no argument is passed, this
 *            assumes the "none" filter.
 * Returns: Array of packages matching the filters.
 */
NAN_METHOD(getPackages) {
  Isolate *isolate = info.GetIsolate();
  PkClient *client = NULL;
  PkResults *pkResults = NULL;
  GPtrArray *array;
  PkPackageSack *sack = NULL;
  PkBitfield filtersBitField;
  GError *err = NULL;
  Handle<Object> pac;
  Handle<Array> result;

  filtersBitField = handleFiltersArgument (info, 0);
  client = pk_client_new();
  pkResults = pk_client_get_packages (
    client, filtersBitField, NULL, (PkProgressCallback) progressCallback, NULL,
    &err
  );

  sack = pk_results_get_package_sack (pkResults);
  pk_package_sack_sort (sack, PK_PACKAGE_SACK_SORT_TYPE_NAME);
  array = pk_package_sack_get_array (sack);

  result = Array::New(isolate, array->len);

  for (unsigned int i=0; i<array->len; i++) {
    PkPackage *package = (PkPackage *) g_ptr_array_index(array, i);
    pac = makePac (package, isolate);
    result->Set (i,pac);
  }

  if (pkResults != NULL)
    g_object_unref (pkResults);
  if (sack != NULL)
    g_object_unref (sack);
  if (client != NULL)
    g_object_unref (client);
  if (array != NULL)
    g_ptr_array_unref(array);
  if (err != NULL)
    g_clear_error(&err);

  info.GetReturnValue().Set(result);
}

/**
 * performAction:
 *
 * Should take as arguments:
 *   action: action to perform, either 'install', 'update' or 'remove' (str)
 *   name: id of the package (str)
 * Returns: true | false (bool)
 */
NAN_METHOD(performAction) {
  Isolate *isolate = info.GetIsolate();
  PkTask *task;
  GError *err = NULL;
  std::basic_string<gchar> action = utf8StringFromValue(info[0]);
  std::basic_string<gchar> name = utf8StringFromValue(info[1]);

  gchar **package_ids = NULL;

  task = pk_task_new();
  package_ids = pk_package_ids_from_id (name.c_str());

  if (action == "install") {
      pk_task_install_packages_sync (task, package_ids, NULL,
                                    (PkProgressCallback) progressCallback,
                                    NULL, &err);
  } else if (action == "update") {
      pk_task_update_packages_sync (task, package_ids, NULL,
                                   (PkProgressCallback) progressCallback,
                                   NULL, &err);
  } else if (action == "remove") {
      pk_task_remove_packages_sync (task, package_ids, TRUE, FALSE, NULL,
                                   (PkProgressCallback) progressCallback,
                                   NULL, &err);
  } else {
      ThrowError(String::NewFromUtf8(
          isolate,
          "You have to provide the action to be performed, either 'install'," 
          "'update' or 'remove'"));
  }

  g_strfreev (package_ids);
  if (err != NULL)
    g_clear_error(&err);

  info.GetReturnValue().Set(Boolean::New(isolate, True));
}

NAN_MODULE_INIT(init) {
  Nan::Set (target, New<String>("searchPackage").ToLocalChecked(),
            GetFunction (New<FunctionTemplate>(searchPackage)).ToLocalChecked());

  Nan::Set (target, New<String>("searchFiles").ToLocalChecked(),
            GetFunction (New<FunctionTemplate>(searchFiles)).ToLocalChecked());

  Nan::Set (target, New<String>("getPackages").ToLocalChecked(),
            GetFunction (New<FunctionTemplate>(getPackages)).ToLocalChecked());

  Nan::Set (target, New<String>("performAction").ToLocalChecked(),
            GetFunction (New<FunctionTemplate>(performAction)).ToLocalChecked());
}

NODE_MODULE(nodepackagekit, init)

