/*
GPII Node.js PackageKit Bridge

Copyright 2012 Steven Githens
Copyright 2013 Emergya
Copyright 2013-2015 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/
#define I_KNOW_THE_PACKAGEKIT_GLIB2_API_IS_SUBJECT_TO_CHANGE 1

#include <nan.h>
#include <packagekit-glib2/packagekit.h>
#include <gio/gio.h>
#include <json-glib/json-glib.h>
#include <string>

/* Set DEBUG to TRUE in order to see the transactions' progress
 * TODO: Allow switching DEBUG value from Node.js side
 */
static gboolean DEBUG = FALSE;

static gchar TAG[] = "[nodePackagekit]";

typedef struct {
  const gchar* property;
  const gchar* (*accessFunc)(PkPackage *package);
} PkitPropAccess;

static std::basic_string<gchar>
utf8StringFromValue(v8::Handle<v8::Value> value)
{
    std::basic_string<gchar> result;
    Nan::Utf8String nanUtf8(value);

    // According to the Nan documentation, if the conversion to Nan::Utf8String
    // fails, then the '*' operator gives a NULL result and not the empty
    // string.  However, its length() method returns zero.  To avoid NULL, check
    // the length, and if zero, skip.
    // https://github.com/nodejs/nan/blob/master/doc/v8_misc.md#nanutf8string
    if (nanUtf8.length() != 0) {
      result.append(*nanUtf8);
    }
    return result;
}

static void
progressCallback(PkProgress *progress, PkProgressType type) {
  if (!DEBUG) return;
  PkStatusEnum status;
  gint percentage;
  gboolean allow_cancel;

  g_object_get(progress,
               "status", &status,
               "percentage", &percentage,
               "allow-cancel", &allow_cancel,
               NULL);

  if (type == PK_PROGRESS_TYPE_STATUS) {
    printf("%s Transaction status: %s\n", TAG, pk_status_enum_to_string(status));
  } else if (type == PK_PROGRESS_TYPE_PERCENTAGE) {
    if (percentage > 0)
      printf("%s Current percentage: %d%%\n", TAG, percentage);
  }
}

static PkBitfield
handleFiltersArgument(const Nan::FunctionCallbackInfo<v8::Value>& args, const int filterIndex) {
  std::basic_string<gchar> filters;

  if (args.Length() > filterIndex) {
    filters = utf8StringFromValue(args[filterIndex]);
  }
  else {
    filters = (gchar *) "none";
  }
  return pk_filter_bitfield_from_string(filters.c_str());
}

static v8::Handle<v8::Object>
makePac(PkPackage *package) {
  v8::Handle<v8::Object> pac = Nan::New<v8::Object>();
  v8::Handle<v8::Value> key;
  v8::Handle<v8::Value> value;
  const gchar *pkString;

  PkitPropAccess propAccess[] = {
    { "id", pk_package_get_id },
    { "name", pk_package_get_name },
    { "version", pk_package_get_version },
    { "arch", pk_package_get_arch },
    { "data", pk_package_get_data },
    { NULL, NULL }
  };

  PkitPropAccess aPropAccess = propAccess[0];
  for (int i = 1; aPropAccess.property != NULL; i++) {
    pkString = aPropAccess.property;
    key = Nan::Encode(pkString, strlen(pkString), Nan::UTF8);
    pkString = (aPropAccess.accessFunc)(package);
    value = Nan::Encode(pkString, strlen(pkString), Nan::UTF8);
    pac->Set(key, value);

    aPropAccess = propAccess[i];
  }
  return pac;
}

/**
 * searchPackage:
 *
 * Should take as arguments:
 *   name:    Name of the package, aka: search criteria (str)
 *   filters: Filters for the search as a string, e.g. "~devel;basename".  See:
 *            http://www.packagekit.org/gtk-doc/introduction-ideas-filters.html
 *            Special case:  the "none" filter = installed or available.
 * Returns: Array of packages matching the search criteria
 */
NAN_METHOD(searchPackage) {
  PkClient *client = NULL;
  PkResults *pkResults = NULL;
  GPtrArray *array;
  PkPackageSack *sack = NULL;
  std::basic_string<gchar> name;
  PkBitfield filtersBitField;
  GError *err = NULL;
  v8::Handle<v8::Object> pac;
  v8::Handle<v8::Array> result;

  name = utf8StringFromValue(info[0]);
  gchar *names[sizeof(name)] = {&name[0]};
  filtersBitField = handleFiltersArgument(info, 1);

  client = pk_client_new();
  pkResults = pk_client_search_names(
    client, filtersBitField, names, NULL,
    (PkProgressCallback) progressCallback, NULL, &err
  );

  sack = pk_results_get_package_sack(pkResults);
  pk_package_sack_sort(sack, PK_PACKAGE_SACK_SORT_TYPE_NAME);
  array = pk_package_sack_get_array(sack);

  result = Nan::New<v8::Array>(array->len);
  for (unsigned int i=0; i<array->len; i++) {
    PkPackage *package = (PkPackage *) g_ptr_array_index(array, i);
    pac = makePac(package);
    result->Set(i, pac);
  }

  g_clear_object(&pkResults);
  g_clear_object(&sack);
  g_clear_object(&client);
  if (array != NULL)
    g_ptr_array_unref(array);
  if (err != NULL)
    g_clear_error(&err);

  info.GetReturnValue().Set(result);
}

/**
 * searchFiles:
 *
 * Should take as arguments:
 *   name:    Path name associated with package, e.g., "/usr/bin/orca".
 *   filters: Filters for the search as a string, e.g. "~devel;basename".  See:
 *            http://www.packagekit.org/gtk-doc/introduction-ideas-filters.html
 *            Special case:  the "none" filter = installed or available.
 * Returns: Array of packages matching the search criteria.
 */
NAN_METHOD(searchFiles) {
  PkClient *client = NULL;
  PkResults *pkResults = NULL;
  GPtrArray *array;
  PkPackageSack *sack = NULL;
  std::basic_string<gchar> pathName;
  PkBitfield filtersBitField;
  GError *err = NULL;
  v8::Handle<v8::Object> pac;
  v8::Handle<v8::Array> result;

  pathName = utf8StringFromValue(info[0]);
  gchar *pathNames[sizeof(pathName)] = {&pathName[0]};
  filtersBitField = handleFiltersArgument(info, 1);

  client = pk_client_new();
  pkResults = pk_client_search_files(
    client, filtersBitField, pathNames, NULL,
    (PkProgressCallback) progressCallback, NULL, &err
  );

  sack = pk_results_get_package_sack(pkResults);
  pk_package_sack_sort(sack, PK_PACKAGE_SACK_SORT_TYPE_NAME);
  array = pk_package_sack_get_array(sack);

  result = Nan::New<v8::Array>(array->len);
  for (unsigned int i=0; i<array->len; i++) {
    PkPackage *package = (PkPackage *) g_ptr_array_index(array, i);
    pac = makePac(package);
    result->Set(i,pac);
  }
  g_clear_object(&pkResults);
  g_clear_object(&sack);
  g_clear_object(&client);
  if (array != NULL)
    g_ptr_array_unref(array);
  if (err != NULL)
    g_clear_error(&err);

  info.GetReturnValue().Set(result);
}

/**
 * getPackages:
 *
 * Should take as arguments:
 *   filters: Filters for list of packages to return, e.g. "installed" or
 *            "~installed", or "~devel;basename".
 *            See:
 *            http://www.packagekit.org/gtk-doc/introduction-ideas-filters.html
 *            Special case:  the "none" filter = installed or available, which
 *            means every possible package.  If no argument is passed, this
 *            assumes the "none" filter.
 * Returns: Array of packages matching the filters.
 */
NAN_METHOD(getPackages) {
  PkClient *client = NULL;
  PkResults *pkResults = NULL;
  GPtrArray *array;
  PkPackageSack *sack = NULL;
  PkBitfield filtersBitField;
  GError *err = NULL;
  v8::Handle<v8::Object> pac;
  v8::Handle<v8::Array> result;

  filtersBitField = handleFiltersArgument(info, 0);
  client = pk_client_new();
  pkResults = pk_client_get_packages(
    client, filtersBitField, NULL, (PkProgressCallback) progressCallback, NULL,
    &err
  );

  sack = pk_results_get_package_sack(pkResults);
  pk_package_sack_sort(sack, PK_PACKAGE_SACK_SORT_TYPE_NAME);
  array = pk_package_sack_get_array(sack);

  result = Nan::New<v8::Array>(array->len);

  for (unsigned int i=0; i<array->len; i++) {
    PkPackage *package = (PkPackage *) g_ptr_array_index(array, i);
    pac = makePac(package);
    result->Set(i,pac);
  }
  g_clear_object(&pkResults);
  g_clear_object(&sack);
  g_clear_object(&client);
  if (array != NULL)
    g_ptr_array_unref(array);
  if (err != NULL)
    g_clear_error(&err);

  info.GetReturnValue().Set(result);
}

/**
 * performAction:
 *
 * Should take as arguments:
 *   action: action to perform, either 'install', 'update' or 'remove' (str)
 *   name: id of the package (str)
 * Returns: true | false (bool)
 */
NAN_METHOD(performAction) {
  PkTask *task;
  GError *err = NULL;
  std::basic_string<gchar> action = utf8StringFromValue(info[0]);
  std::basic_string<gchar> name = utf8StringFromValue(info[1]);

  gchar **package_ids = NULL;

  task = pk_task_new();
  package_ids = pk_package_ids_from_id(name.c_str());

  if (action == "install") {
      pk_task_install_packages_sync(task, package_ids, NULL,
                                    (PkProgressCallback) progressCallback,
                                    NULL, &err);
  } else if (action == "update") {
      pk_task_update_packages_sync(task, package_ids, NULL,
                                   (PkProgressCallback) progressCallback,
                                   NULL, &err);
  } else if (action == "remove") {
      pk_task_remove_packages_sync(task, package_ids, TRUE, FALSE, NULL,
                                   (PkProgressCallback) progressCallback,
                                   NULL, &err);
  } else {
      g_clear_object(&task);
      task = NULL;
      g_strfreev(package_ids);
      package_ids = NULL;
      Nan::ThrowError(
          "You have to provide the action to be performed, either 'install', " 
          "'update' or 'remove'");
  }
  g_clear_object(&task);
  g_strfreev(package_ids);
  if (err != NULL)
    g_clear_error(&err);

  info.GetReturnValue().Set(Nan::True());
}

NAN_MODULE_INIT(init) {
  Nan::Set(target, Nan::New<v8::String>("searchPackage").ToLocalChecked(),
           Nan::GetFunction(Nan::New<v8::FunctionTemplate>(searchPackage)).ToLocalChecked());

  Nan::Set(target, Nan::New<v8::String>("searchFiles").ToLocalChecked(),
           Nan::GetFunction(Nan::New<v8::FunctionTemplate>(searchFiles)).ToLocalChecked());

  Nan::Set(target, Nan::New<v8::String>("getPackages").ToLocalChecked(),
            Nan::GetFunction(Nan::New<v8::FunctionTemplate>(getPackages)).ToLocalChecked());

  Nan::Set(target, Nan::New<v8::String>("performAction").ToLocalChecked(),
            Nan::GetFunction(Nan::New<v8::FunctionTemplate>(performAction)).ToLocalChecked());
}

NODE_MODULE(nodepackagekit, init)

