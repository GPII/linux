# GPII Process Reporter

The GPII prcoesses reporter is made up of two parts:

* a Nodejs bridge to GNOME/Linux's [libgtop library](https://developer.gnome.org/libgtop/stable/) to acquire information about running processes.
* a fluid evented component that provides an interface for:
  * locating processes based on solution "commands".
  * locating processes based on solution process ids.
  * locating processes by command.
  * locating a process by its process id.
  * emitting an event when a process changes state (`onStateChange`).
  * emitting an event when a process switch run state (`onRunStateChange`).

Here is how the parts fit together, from the bottom up.

## Nodejs Bridge

The code for the bridge is in the sub-folder "nodeprocesses".  In essence, it consists of one JavaScript function to acquire a list of all the processes on the machine, and represnt each process as a set of properties.

The first property, "command", is provided by libgtop and is conceptually the name of the process.  Both GNOME/Linux and Mac OS X have a GUI process viewer where they display this property as the "process name".  Nodejs has a "process" global object, which represents the Nodejs process itself, that uses a "title" property for the same purpose.  Within bash, a simple way to find a process is to list them all using `ps` and then `grep` for the command name, e.g.:

```$ ps aux | grep node```

Unfortunately, the command name is not unique in the sense that more than one process can have the same name.  There can be multiple "node" processes runnning simultaneously.  The process id, however, is unique.  Once a process has been found via its command name, thereafter, one can use its process id to reference that one process.

The full set of properties are:

* command - a string that identifies the command associated with the process.
* pid - an integer that uniquely identifies the process
* ppid - the parent process id, unique to the parent.
* uid - an integer that uniquely identifies the associated user.
* gid - an integer that uniquely identifies the group the user belongs to.
* fullPath - the full path to the executable that launched the process.
* argv - the array of arguments passed to the executable at launch.
* state - a string representing the current state of the process.

Using orca as an example, the structure is:

```
{
    command: 'orca',
    pid: 7330,
    ppid: 1315,
    uid: 1000,
    gid: 1000,
    fullPath: '/usr/bin/python3',
    argv: [ '/usr/bin/python3', '/usr/bin/orca' ],
    state: 'Sleeping'
}
```

The state property can have a number of values, listed below.  These are grouped according to how the processReporter component sees a process as "running" vs. "not-running":

* running:
 * "Running"
 * "Uninterruptible"
 * "Sleeping"
 * "Stopped"
* not-running:
 * "Zombie"
 * "NoSuchProcess"

Note: "NoSuchProcess" is *not* returned by the nodeprocess bridge, nor the GNOME/Linux process library.  If there is no process matching a pid or command, then there is no process information provided.  The processReporter component adds the "NoSuchProcess" state as a special case.

### Building Nodejs Bridge

Use the grunt file in the parent "linux" folder:

`$ grunt shell:compileProcesses`

## Process Reporter

The process reporter is a fluid evented component that makes use of the nodeprocesses bridge and provides filters for locating processes by command, or by process id.  There are also methods for determing if a process has changed state, and, in particular, whether the process has switched between a "running" state vs. a "not-running" state.  The relevant files are:

* processReporter.js - the process reporter component.
* processReporter_tests.js - unit tests for the componenet.
* processReporterDemo.js - a demo script that tracks the status of the "orca' process.

There are two experimental features of the reporter that likely require more thought.  The first of these is a reliance on ```setInterval()``` to periodically check the status of a given process.  The second is a guess as to how the proces reporter could interface with the solutions registry to determine if a solution is running or not.

### Events `onRunStateChange` and `onStateChange`

With respect to periodically checking for a change in process status, processReporter provides two events, each with methods for attaching listeners that react to changes in process status.

The `onRunStateChange` event is fired when a process changes from a "running" state to a "not-running" state.  The method `trackRunState()` takes a process information structure, and a handler function as input.  It sets up a periodic check of the state of the given process using the global ```setInterval()```.  If the process status changes from  "running" to "not-running" or "not-running" to "running", the given handler function is called.  The `trackRunState()` method returns the interval identifier returned by ```setInterval()```; however, the procesReporter provides a method `stopTrackingRunState()` for shutting down the entire tracking mechanics, including clearing the interval.

There is also a `onStateChange` event, and associated methods `trackState()` and `stopTrackingState()` that can be used to periodically check *any* change in state of the given prcoess, and react to the change.

A demonstration of the use of these events is provided in "processReporterDemo.js", using the Orca screen reader. The steps to run the demo are:

 1. `$ node processReporterDemo.js`
 2. Start a separate terminal session.
 3. In this separate terminal, start/stop Orca the way GPII does:
  * `$ gsettings set org.gnome.desktop.a11y.applications screen-reader-enabled true`
  * `$ gsettings set org.gnome.desktop.a11y.applications screen-reader-enabled false`

### Interface with Solutions Registry

The process reporter also provides a preliminary way for locating processes based on "commands" as provided by the solutions registry.

In the current solutions registry structure, a solution entry contains a pair of commands to start and stop that solution.  These are in the lifeCycleManager sub-structure.  In some cases, the actual commands/processes ultimately launched are not specified, but are invoked indirectly by changing a system setting.

Using Orca as an example, the way to start Orca, if it is not running, is to change the "screen-reader-enabled" setting. Changing that settting from "false" to "true" eventuates in a call to another command that launches the orca process.

In other words, the process of interest is not directly launched by GPII; the orca process is indirectly launched by changing a setting.

To make this concrete, here is the lifecycleManager object for the "ORCA Screen Reader" solution entry:

```
"lifecycleManager": {
    "start": [
        "setSettings",
        {
            "type": "gpii.launch.exec",
            "command": "gsettings set org.gnome.desktop.a11y.applications screen-reader-enabled true"
        }
    ],
    "stop": [
        {
            "type": "gpii.launch.exec",
            "command": "gsettings set org.gnome.desktop.a11y.applications screen-reader-enabled false"
        },
        "restoreSettings"
    ]
}
```

There needs to be something in the life cycle structure that documents what *comamnd* corresponds to the orca process.  I'm assuming whatever that is, it can be passed to the process reporter's `findSolutionsByCommands()` to search the process list and find and return matching processes.  From then on, the rest of the processReporter machinery can be used to track the state of that process, even when it is shut down by changing the screen-reader-enable setting to false.
