/*
GPII Node.js Processes (glibtop) Bridge

Copyright 2014 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

#include <nan.h>
#include <glib.h>
#include <glibtop.h>
#include <glibtop/proclist.h>
#include <glibtop/procstate.h>
#include <glibtop/procargs.h>
#include <glibtop/procuid.h>
#include <json-glib/json-glib.h>
#include <string>

using namespace v8;
using v8::FunctionTemplate;
using v8::Handle;
using v8::Object;
using v8::String;
using v8::Value;
using v8::Array;
using Nan::GetFunction;
using Nan::New;
using Nan::Set;

static glibtop* glibtopPtr = NULL;

const char* STATE_RUNNING           = "Running";
const char* STATE_STOPPED           = "Stopped";
const char* STATE_ZOMBIE            = "Zombie";
const char* STATE_UNINTERRUPTIBLE   = "Uninterruptible";
const char* STATE_SLEEPING          = "Sleeping";

const guint64 GET_ALL_ARGS          = 0;
const guint64 KERN_PROC_ALL_ARG     = 0;

static Handle<Value>
nanEncodeUtf8 (const char* string) {
    return Nan::Encode (string, strlen (string), Nan::UTF8);
}


// The following is based on code in gnome-system-monitor (the "System Monitor"
// application).  The problem is the command name in the glibtop_proc_state
// struct is truncated.  The full name is in the process arguments vector.

static Handle<Value>
get_process_name (const gchar *cmd, const char** argv)
{
    char *basename = NULL;
    Handle<Value> procname;

    if (argv) {
        // look for /usr/bin/very_long_name (argv[0]), or
        // /usr/bin/interpreter /usr/.../very_long_name (argv[1])
        // which may have used prctl to alter 'cmd' name.
        for (int i = 0; i != 2 && argv[i]; i++) {
            basename = g_path_get_basename (argv[i]);
            if (g_str_has_prefix (basename, cmd)) {
                break;
            }
            g_free (basename);
            basename = NULL;
        }
    }
    if (basename != NULL) {
        procname = nanEncodeUtf8 (basename);
        g_free (basename);
    }
    else {
        procname = nanEncodeUtf8 (cmd);
    }
    return procname;
}

static Handle<Value>
format_process_state (guint state)
{
    Handle<Value> status;

    switch (state)
    {
        case GLIBTOP_PROCESS_RUNNING:
            status = nanEncodeUtf8 (STATE_RUNNING);
            break;

        case GLIBTOP_PROCESS_STOPPED:
            status = nanEncodeUtf8 (STATE_STOPPED);
            break;

        case GLIBTOP_PROCESS_ZOMBIE:
            status =nanEncodeUtf8 (STATE_ZOMBIE);
            break;

        case GLIBTOP_PROCESS_UNINTERRUPTIBLE:
            status = nanEncodeUtf8 (STATE_UNINTERRUPTIBLE);
            break;

        default:
            status = nanEncodeUtf8 (STATE_SLEEPING);
            break;
    }
    return status;
}

static Handle<Object>
makeProcInfo (pid_t pid) {
    glibtop_proc_state procstate;
    glibtop_proc_args procargs;
    glibtop_proc_uid procuid;
    char** argv = NULL;

    Handle<Value> encodedString;
    Handle<Value> procname;
    Handle<Value> fullPath = Nan::EmptyString();
    Handle<Array> arguments = Nan::New<Array>();
    Handle<Object> procInfo = Nan::New<Object>();

    glibtop_get_proc_state (&procstate, pid);
    glibtop_get_proc_uid (&procuid, pid);

    // Get the argument vector of the process and store the arguments in a v8 
    // array.  The first element in argv is usually (alas, not always) the
    // full path to the executable.  Store that as a separate property.
    argv = glibtop_get_proc_argv (&procargs, pid, GET_ALL_ARGS);
    if (argv != NULL) {
      if (argv[0] != NULL) {
        fullPath = nanEncodeUtf8 (argv[0]);
      }
      for (int i = 0; argv[i]; i++) {
        arguments->Set (i, nanEncodeUtf8 (argv[i]));
      }
    }
    procname = get_process_name (procstate.cmd, (const char**) argv);
    procInfo->Set (nanEncodeUtf8 ("command"), procname);
    procInfo->Set (nanEncodeUtf8 ("pid"), Nan::New<Integer> (pid));
    procInfo->Set (nanEncodeUtf8 ("ppid"), Nan::New<Integer> (procuid.ppid));
    procInfo->Set (nanEncodeUtf8 ("uid"), Nan::New<Integer> (procuid.uid));
    procInfo->Set (nanEncodeUtf8 ("gid"), Nan::New<Integer> (procuid.gid));
    procInfo->Set (nanEncodeUtf8 ("fullPath"), fullPath);
    procInfo->Set (nanEncodeUtf8 ("argv"), arguments);
    procInfo->Set (nanEncodeUtf8 ("state"), format_process_state (procstate.state));

    if (argv != NULL)
      g_strfreev (argv);

    return (procInfo);
}

/**
 * getProcesses:
 *
 * Returns: Array of currently running processes.
 * FIXME:  make "Returns:" more explicit.
 */
NAN_METHOD(getProcesses) {
    pid_t* pidArray = NULL;
    glibtop_proclist procList;
    Handle<Object> procInfo;

    pidArray = glibtop_get_proclist (&procList, GLIBTOP_KERN_PROC_ALL, KERN_PROC_ALL_ARG);

    Local<Array> result = Nan::New<Array> (procList.number);
    for (unsigned int i=0; i<procList.number; i++) {
      procInfo = makeProcInfo (pidArray[i]);
      result->Set (i, procInfo);
    }
    if (pidArray != NULL)
      g_free (pidArray);

    info.GetReturnValue().Set (result);
}

NAN_MODULE_INIT(init) {
    // Safe to call glibtop_init() since it does nothing if already initialized,
    // and it returns a pointer to the glibtop structure.
    glibtopPtr = glibtop_init();

    Nan::Set (target, New<String>("getProcesses").ToLocalChecked(),
              GetFunction (New<FunctionTemplate>(getProcesses)).ToLocalChecked());
}

NODE_MODULE(nodeprocesses, init)

