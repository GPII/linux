/*
GPII Node.js Processes (glibtop) Bridge

Copyright 2014 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

#include <node.h>
#include <v8.h>
#include <glib.h>
#include <glibtop.h>
#include <glibtop/proclist.h>
#include <glibtop/procstate.h>
#include <glibtop/procargs.h>
#include <glibtop/procuid.h>
#include <json-glib/json-glib.h>
#include <string>

using namespace v8;

static glibtop* glibtopPtr = NULL;

const char* STATE_RUNNING         = "Running";
const char* STATE_STOPPED         = "Stopped";
const char* STATE_ZOMBIE          = "Zombie";
const char* STATE_UNINTERRUPTIBLE = "Uninterruptible";
const char* STATE_SLEEPING        = "Sleeping";

// The following is based on code in gnome-system-monitor (the "System Monitor"
// application).  The problem is the command name in the glibtop_proc_state
// struct is truncated.  The full name is in the process arguments vector.

static v8::Local<v8::String>
get_process_name (const gchar *cmd, const char** argv)
{
    char *basename = NULL;
    v8::Local<v8::String> procname;

    if (argv) {
        // look for /usr/bin/very_long_name (argv[0]), or
        // /usr/bin/interpreter /usr/.../very_long_name (argv[1])
        // which may have used prctl to alter 'cmd' name.
        for (int i = 0; i != 2 && argv[i]; i++) {
            basename = g_path_get_basename (argv[i]);
            if (g_str_has_prefix (basename, cmd)) {
                break;
            }
            g_free (basename);
            basename = NULL;
        }
    }
    if (basename != NULL) {
        procname = String::New (basename);
        g_free (basename);
    }
    else {
        procname = String::New (cmd);
    }
    return procname;
}


static v8::Local<v8::String>
format_process_state (guint state)
{
    v8::Local<v8::String> status;

    switch (state)
    {
        case GLIBTOP_PROCESS_RUNNING:
            status = String::New (STATE_RUNNING);
            break;

        case GLIBTOP_PROCESS_STOPPED:
            status = String::New (STATE_STOPPED);
            break;

        case GLIBTOP_PROCESS_ZOMBIE:
            status = String::New (STATE_ZOMBIE);
            break;

        case GLIBTOP_PROCESS_UNINTERRUPTIBLE:
            status = String::New (STATE_UNINTERRUPTIBLE);
            break;

        default:
            status = String::New (STATE_SLEEPING);
            break;
    }
    return status;
}


static v8::Handle<v8::Object>
makeProcInfo (pid_t pid, glibtop_proclist* procList) {
    glibtop_proc_state procstate;
    glibtop_proc_args procargs;
    glibtop_proc_uid procuid;
    char** argv = NULL;

    v8::Local<v8::String> procname;
    v8::Local<v8::String> fullPath = String::Empty();
    v8::Handle<v8::Array> arguments = v8::Array::New();
    v8::Handle<v8::Object> procInfo = v8::Object::New();

    glibtop_get_proc_state (&procstate, pid);
    glibtop_get_proc_uid (&procuid, pid);

    argv = glibtop_get_proc_argv (&procargs, pid, 0);
    if (argv != NULL) {
      if (argv[0] != NULL)
        fullPath = String::New (argv[0]);

      for (int i = 0; argv[i]; i++) {
        arguments->Set (i, String::New(argv[i]));
      }
    }
    procname = get_process_name (procstate.cmd, (const char**) argv);
    procInfo->Set(String::New("command"), procname);
    procInfo->Set(String::New("pid"), Integer::New (pid));
    procInfo->Set(String::New("ppid"), Integer::New (procuid.ppid));
    procInfo->Set(String::New("uid"), Integer::New (procuid.uid));
    procInfo->Set(String::New("gid"), Integer::New (procuid.gid));
    procInfo->Set(String::New("fullPath"), fullPath);
    procInfo->Set(String::New("argv"), arguments);
    procInfo->Set(String::New("state"), format_process_state (procstate.state));

    if (argv != NULL)
      g_strfreev (argv);

    return (procInfo);
}

/**
 * getProcesses:
 *
 * Returns: Array of currently running processes.
 * FIXME:  make "Returns:" more explicit.
 */
Handle<Value> getProcesses (const Arguments& args) {
    HandleScope scope;
    pid_t* pidArray = NULL;
    glibtop_proclist procList;
    v8::Handle<v8::Object> procInfo;
    v8::Handle<v8::Array> result = v8::Array::New();

    gint64 which = GLIBTOP_KERN_PROC_ALL;
    gint64 arg = 0;

    pidArray = glibtop_get_proclist (&procList, which, arg);

    for (unsigned int i=0; i<procList.number; i++) {
      procInfo = makeProcInfo (pidArray[i], &procList);
      result->Set (i, procInfo);
    }
    if (pidArray != NULL)
      g_free (pidArray);

    return scope.Close (result);
}

void init(Handle<Object> target) {
    // Safe to call glibtop_init() since it does nothing if already initialized,
    // and it returns a pointer to the glibtop structure.
    glibtopPtr = glibtop_init();

    target->Set(String::NewSymbol("getProcesses"),
                FunctionTemplate::New(getProcesses)->GetFunction());
}

NODE_MODULE(nodeprocesses, init)

