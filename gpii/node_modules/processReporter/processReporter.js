/*!
GPII Process Reporter -- gpii.processReporter.

Copyright 2014 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

/*global require */

(function() {
    "use strict";

    var fluid = require ("universal");
    var gpii = fluid.registerNamespace ("gpii");
    var nodeProcesses = require ("./nodeprocesses/build/Release/nodeprocesses.node");

    gpii.processReporter = fluid.registerNamespace ("gpii.processReporter");

    fluid.defaults ("gpii.processReporter", {
      gradeNames: ["fluid.eventedComponent", "autoInit"],
      events: {
        onRunStateChange: null,
        onStateChange: null
      },
      invokers: {
        findSolutionsByCommands: {
          funcName: "gpii.processReporter.findSolutionsByCommands",
          args: ["{arguments}.0"]   // array of command names
        },
        findSolutionsByPids: {
          funcName: "gpii.processReporter.findSolutionsByPids",
          args: ["{arguments}.0"]   // array of pid (process ids)
        },
        getProcesses: {
          funcName: "gpii.processReporter.getProcesses",
          args: []
        },
        findProcessByPid: {
          funcName: "gpii.processReporter.findProcessByPid",
          args: ["{arguments}.0", "{arguments}.1"] // pid, procArray (optional)
        },
        findProcessesByCommand: {
          funcName: "gpii.processReporter.findProcessesByCommand",
          args: ["{arguments}.0", "{arguments}.1"] // command, procArray (optional)
        },
        findFirstProcessByCommand: {
          funcName: "gpii.processReporter.findFirstProcessByCommand",
          args: ["{arguments}.0", "{arguments}.1"] // command, procArray (optional)
        },
        hasStateChanged: {
          funcName: "gpii.processReporter.hasStateChanged",
          args: ["{arguments}.0"]   // process info structure
        },
        isRunning: {
          funcName: "gpii.processReporter.isRunning",
          args: ["{arguments}.0"]   // state (string)
        },
        hasSwitchRunState: {
          funcName: "gpii.processReporter.hasSwitchedRunState",
          args: ["{arguments}.0"]   // monitor info structure
        },
        updateProcInfo: {
          funcName: "gpii.processReporter.updateProcInfo",
          args: ["{arguments}.0"]   // process info structure
        },
        initProcInfoNotRunning: {
          funcName: "gpii.processReporter.initProcInfoNotRunning",
          args: ["{arguments}.0"]   // command name (string)
        },
        initMonitor: {
          funcName: "gpii.processReporter.initMonitor",
          args: ["{arguments}.0"]   // process info structure
        },
        monitorStateChange: {
          funcName: "gpii.processReporter.monitorStateChange",
          args: ["{that}", "{arguments}.0"] // monitor info structure
        },
        monitorRunStateChanged: {
          funcName: "gpii.processReporter.monitorRunStateChanged",
          args: ["{that}", "{arguments}.0"] // monitor info structure
        },
        trackRunState: {
          funcName: "gpii.processReporter.trackRunState",
          args: ["{that}", "{arguments}.0", "{arguments}.1"] // process info, handler
        },
        stopTrackingRunState: {
          funcName: "gpii.processReporter.stopTrackingRunState",
          args: ["{that}", "{arguments}.0", "{arguments}.1"] // handler, intervalID
        },
        // Tracking *any* state change.
        trackState: {
          funcName: "gpii.processReporter.trackState",
          args: ["{that}", "{arguments}.0", "{arguments}.1"] // process info, handler
        },
        stopTrackingState: {
          funcName: "gpii.processReporter.stopTrackingState",
          args: ["{that}", "{arguments}.0", "{arguments}.1"] // handler, intervalID
        }
      }
    });

    // Return an list of process information structures corresponding to the
    // names of each of the passed in commands.
    gpii.processReporter.findSolutionsByCommands = function (commandNames) {
      if (!!commandNames) {
       return fluid.accumulate (commandNames, function (aCommand, matches) {
          var procInfos = gpii.processReporter.findProcessesByCommand (aCommand);
          matches = matches.concat (procInfos);
          return matches;
        }, []);
      }
      else {
        return [];
      }
    },

    // Return an list of process information structures corresponding to the
    // pids pass in.
    gpii.processReporter.findSolutionsByPids = function (pids) {
      if (!!pids) {
        return fluid.accumulate (pids, function (aPid, matches) {
          var found = gpii.processReporter.findProcessByPid (aPid);
          if (found !== null) {
            matches.push (found);
          }
          return matches;
        }, []);
      }
      else {
        return [];
      }
    },

    // Return a list of processes -- a snapshot of the current processes.
    gpii.processReporter.getProcessList = function() {
      return nodeProcesses.getProcesses();
    };

    // Return THE process info object that matches the given process id.
    // Note that it can return "null" meaning there is no such process.
    gpii.processReporter.findProcessByPid = function (pid, procArray) {
      if (!procArray) {
        procArray = gpii.processReporter.getProcessList();
      }
      return fluid.find (procArray, function (procInfo) {
         if (procInfo.pid === pid) {
            return procInfo;
         }
      }, null);
    };

    // Return an array of process information objects that match the given
    // command name string.  Note that it can return an empty array, meaning
    // there is no such process.
    gpii.processReporter.findProcessesByCommand = function (commandName, procArray) {
      if (!procArray) {
        procArray = gpii.processReporter.getProcessList();
      }
      return fluid.accumulate (procArray, function (aProcInfo, matchingProcs) {
         if (aProcInfo.command === commandName) {
            matchingProcs.push (aProcInfo);
         }
         return matchingProcs;
      }, []);
    };

    // Return the first process of an array of processes all with the same
    // command name string.  If there are no matching processes, return null.
    gpii.processReporter.findFirstProcessByCommand = 
    function (commandName, procArray) {
      var commands = 
        gpii.processReporter.findProcessesByCommand (commandName, procArray);
      if (commands.length > 0) {
        return commands[0];
      }
      else {
        return null;
      }
    };

    // Determine if the state of the given process has changed.  Record the
    // new process information in the monitor.  Return boolean.
    gpii.processReporter.hasStateChanged = function (monitor) {
      if (!monitor ||!monitor.procInfo) {
        return false;    // nothing sought === nothing changed.
      }
      monitor.newProcInfo = 
        gpii.processReporter.updateProcInfo (monitor.procInfo);
      return (monitor.procInfo.state !== monitor.newProcInfo.state);
    };

    // Utility function to conflate process state values into "Running"
    // (= true) vs. "Not Running" (= false).  Returns boolean.
    gpii.processReporter.isRunning = function (state) {
      var result;
      switch (state) {
        case "Running":
        case "Uninterruptible":
        case "Sleeping":
        case "Stopped":
          result = true;
          break;

        default:
        case "Zombie":
        case "NoSuchProcess":
          result = false;
          break;
      }
      return result;
    };

    // Determine if the state of the given process has changed from
    // "not running" to "running" OR from "running" to "not running".
    // Return boolean.
    gpii.processReporter.hasSwitchedRunState = function (monitor) {
      if (!monitor || !monitor.procInfo) {
        // nothing sought === nothing changed.
        return false;
      }
      monitor.newProcInfo = 
        gpii.processReporter.updateProcInfo (monitor.procInfo);
      var wasRunning = gpii.processReporter.isRunning (monitor.procInfo.state);
      var isRunning =  gpii.processReporter.isRunning (monitor.newProcInfo.state);
      return (isRunning !== wasRunning);
    };

    // Renew the information on a process, or create a new "NoSuchProcces".
    // Returns a new procInfo structure.
    gpii.processReporter.updateProcInfo = function (procInfo) {
      var newProcInfo = null;
      if (procInfo.state === "NoSuchProcess") {
        newProcInfo = gpii.processReporter.findFirstProcessByCommand (procInfo.command);
      }
      else {
        newProcInfo = gpii.processReporter.findProcessByPid (procInfo.pid);
      }
      if (newProcInfo === null) {
        newProcInfo = gpii.processReporter.initProcInfoNotRunning (procInfo.command);
      }
      return newProcInfo;
    };

    // Create information on a non-running process, to use to detect when the
    // process starts.
    gpii.processReporter.initProcInfoNotRunning = function (command) {
      var process = {};
      process.command = command;
      process.pid = -1;
      process.ppid = -1;
      process.uid = -1;
      process.gid = -1;
      process.fullPath = "";
      process.argv = "";
      process.state = "NoSuchProcess";
      return process;
    };

    // Create a monitor object for passing to a function that periodically
    // checks for chanages in the state of a process.
    gpii.processReporter.initMonitor = function (procInfo) {
      var monitor = {};
      monitor.intervalID = -1;
      monitor.procInfo = procInfo;
      monitor.newProcInfo = null;
      return monitor;
    };

    // Callback to pass to, e.g., setInterval() to periodically check the state
    // of a process.
    gpii.processReporter.monitorStateChange = function (that, monitor) {
      if (gpii.processReporter.hasStateChanged (monitor)) {
        var oldProcInfo = monitor.procInfo;
        if (monitor.newProcInfo === null) {
          monitor.procInfo =
            gpii.processReporter.initProcInfoNotRunning (monitor.procInfo.command);
        }
        else {
          monitor.procInfo = monitor.newProcInfo;
        }
        that.events.onStateChange.fire (oldProcInfo, monitor.newProcInfo);
      }
    };

    // Callback to pass to setInterval() to periodically check when the state
    // changes from "running" to "not running" and vice versa.
    gpii.processReporter.monitorRunStateChanged = function (that, monitor) {
      if (gpii.processReporter.hasSwitchedRunState (monitor)) {
        if (monitor.newProcInfo === null) {
          monitor.procInfo =
            gpii.processReporter.initProcInfoNotRunning (monitor.procInfo.command);
        }
        else {
          monitor.procInfo = monitor.newProcInfo;
        }
        that.events.onRunStateChange.fire (monitor.procInfo);
      }
    };

    // ==============
    // Event handling
    // ==============

    // Provide a way for the outside world to pass in a handler for the
    // "onRunStateChange" event, and to cancel.
    gpii.processReporter.trackRunState = function (that, procInfo, handler) {
      var monitor = gpii.processReporter.initMonitor (procInfo);
      that.events.onRunStateChange.addListener (handler);
      monitor.intervalID = setInterval (function() {
        gpii.processReporter.monitorRunStateChanged (that, monitor);
      });
      return monitor.intervalID;
    };

    gpii.processReporter.stopTrackingRunState = function (that, handler, intervalID) {
      that.events.onRunStateChange.removeListener (handler);
      clearInterval (intervalID);
    };

    // Provide a way for the outside world to pass in a handler for the
    // "onStateChange" event, and to cancel.
    gpii.processReporter.trackState = function (that, procInfo, handler) {
      var monitor = gpii.processReporter.initMonitor (procInfo);
      that.events.onStateChange.addListener (handler);
      monitor.intervalID = setInterval (function() {
        gpii.processReporter.monitorStateChange (that, monitor);
      });
      return monitor.intervalID;
    };

    gpii.processReporter.stopTrackingState = function (that, handler, intervalID) {
      that.events.onStateChange.removeListener (handler);
      clearInterval (intervalID);
    };

}());
