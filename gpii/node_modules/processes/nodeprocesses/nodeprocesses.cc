/*
GPII Node.js Processes (glitop) Bridge

Copyright 2014 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

#include <node.h>
#include <v8.h>
#include <glibtop.h>
#include <glibtop/proclist.h>
#include <glibtop/procstate.h>
#include <glibtop/procargs.h>
#include <glibtop/procuid.h>
#include <json-glib/json-glib.h>
//#include <string>

using namespace v8;

static glibtop* glibtopPtr = NULL;

// static std::basic_string<gchar>
// utf8StringFromValue(v8::Handle<v8::Value> value)
// {
//     v8::Local<v8::String> string = value->ToString();
//     gchar *buffer = g_new(gchar, string->Utf8Length());
//     string->WriteUtf8(buffer);
//     return buffer;
// }

v8::Local<v8::String>
format_process_state (guint state)
{
    v8::Local<v8::String> status;

    switch (state)
    {
        case GLIBTOP_PROCESS_RUNNING:
            status = String::New ("Running");
            break;

        case GLIBTOP_PROCESS_STOPPED:
            status = String::New ("Stopped");
            break;

        case GLIBTOP_PROCESS_ZOMBIE:
            status = String::New ("Zombie");
            break;

        case GLIBTOP_PROCESS_UNINTERRUPTIBLE:
            status = String::New ("Uninterruptible");
            break;

        default:
            status = String::New ("Sleeping");
            break;
    }
    return status;
}


static v8::Handle<v8::Object>
makeProcInfo (pid_t pid, glibtop_proclist* procList) {
    glibtop_proc_state procstate;
    glibtop_proc_args procargs;
    glibtop_proc_uid procuid;
    char** argv = NULL;

    v8::Local<v8::String> fullPath = String::Empty();
    v8::Handle<v8::Array> arguments = v8::Array::New();

    glibtop_get_proc_state (&procstate, pid);
    glibtop_get_proc_uid (&procuid, pid);

    argv = glibtop_get_proc_argv (&procargs, pid, 0);
    if (argv != NULL) {
      if (argv[0] != NULL)
        fullPath = String::New (argv[0]);

      for (int i = 0; argv[i]; i++) {
        arguments->Set (i, String::New(argv[i]));
      }
    }

    v8::Handle<v8::Object> procInfo = v8::Object::New();
    procInfo->Set(String::New("pid"), Integer::New(pid));
    procInfo->Set(String::New("uid"), Integer::New(procuid.uid));
    procInfo->Set(String::New("gid"), Integer::New(procuid.gid));
    procInfo->Set(String::New("command"), String::New (procstate.cmd));
    procInfo->Set(String::New("fullPath"), fullPath);
    procInfo->Set(String::New("argv"), arguments);
    procInfo->Set(String::New("state"), format_process_state (procstate.state));
    
    if (argv != NULL)
      g_strfreev (argv);

    return (procInfo);
}

/**
 * getProcesses:
 *
 * Returns: Array of currently running processes.
 * FIXME:  make "Returns:" more explicit.
 */
Handle<Value> getProcesses (const Arguments& args) {
    HandleScope scope;
    pid_t* pidArray = NULL;
    glibtop_proclist procList;
//  GPtrArray *array;
    GError *err = NULL;
    v8::Handle<v8::Object> procInfo;
    v8::Handle<v8::Array> result = v8::Array::New();

    // FIXME (JS): maybe make use of Arguments &args to shape the process list.
    // Possible values for which = all vs. user vs. group
    // Possible values for arg = 0 vs. user id vs. group id
    //
    gint64 which = GLIBTOP_KERN_PROC_ALL;
    gint64 arg = 0;

    pidArray = glibtop_get_proclist (&procList, which, arg);

    for (unsigned int i=0; i<procList.number; i++) {
      procInfo = makeProcInfo (pidArray[i], &procList);
      result->Set (i, procInfo);
    }
    if (pidArray != NULL)
      g_free (pidArray);

    return scope.Close (result);
}

void init(Handle<Object> target) {
    // Safe to call glibtop_init() since it does nothing if already initialized,
    // and it returns a pointer to the glibtop structure.
    glibtopPtr = glibtop_init();

    target->Set(String::NewSymbol("getProcesses"),
                FunctionTemplate::New(getProcesses)->GetFunction());
}

NODE_MODULE(nodeprocesses, init)

