/*
 * GPII Xrandr Bridge
 *
 * Copyright 2013 Emergya
 * Copyright 2015 Raising the Floor
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

#include <nan.h>

#include <stdio.h>
#include <iso646.h>
#include <X11/Xlib.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xatom.h>
#include <X11/extensions/Xrandr.h>
#include <X11/extensions/Xrender.h>
#include <strings.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#include <stdarg.h>
#include <math.h>

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

using namespace v8;
using v8::FunctionTemplate;
using v8::Handle;
using v8::Isolate;
using v8::Object;
using v8::String;
using Nan::GetFunction;
using Nan::New;
using Nan::Set;

using namespace std;

typedef enum _name_kind {
    name_none = 0,
    name_string = (1 << 0),
    name_xid = (1 << 1),
    name_index = (1 << 2),
    name_preferred = (1 << 3),
} name_kind_t;

typedef struct {
    name_kind_t	    kind;
    char    	    *string;
    XID	    	    xid;
    int		    index;
} name_t;

static void
init_name (name_t *name)
{
    name->kind = name_none;
}

static void
set_name_xid (name_t *name, XID xid)
{
    name->kind |= name_xid;
    name->xid = xid;
}

static double
mode_refresh (XRRModeInfo *mode_info)
{
    double rate;
    unsigned int vTotal = mode_info->vTotal;

    if (mode_info->modeFlags & RR_DoubleScan) {
        /* doublescan doubles the number of lines */
        vTotal *= 2;
    }

    if (mode_info->modeFlags & RR_Interlace) {
        /* interlace splits the frame into two fields */
        /* the field rate is what is typically reported by monitors */
        vTotal /= 2;
    }

    if (mode_info->hTotal && vTotal)
        rate = ((double) mode_info->dotClock /
                ((double) mode_info->hTotal * (double) vTotal));
    else
        rate = 0;
    return rate;
}

static XRRModeInfo *
find_mode (name_t *name, double refresh, XRRScreenResources *res)
{
    int m;
    XRRModeInfo *best = NULL;
    double bestDist = 0;

    for (m = 0; m < res->nmode; m++)
    {
	XRRModeInfo *mode = &res->modes[m];
        if ((name->kind & name_xid) && name->xid == mode->id)
        {
            best = mode;
            break;
        }
        if ((name->kind & name_string) && !strcmp (name->string, mode->name))
        {
            double dist;

            if (refresh)
                dist = fabs (mode_refresh (mode) - refresh);
            else
                dist = 0;
            if (!best || dist < bestDist)
            {
                bestDist = dist;
                best = mode;
            }
      	}
    }
    return best;
}

static XRRModeInfo *
find_mode_by_xid (RRMode mode, XRRScreenResources *res)
{
    name_t  mode_name;

    init_name (&mode_name);
    set_name_xid (&mode_name, mode);
    return find_mode (&mode_name, 0, res);
}

NAN_METHOD(getDisplays) {
    Display *dpy;
    Window  root;
    XRRScreenResources *res;
    XRRScreenConfiguration *sc;

    Isolate *isolate = info.GetIsolate();
    Handle<Array> result = Array::New(isolate);

    char *display_name = NULL;
    int screen = -1;

    dpy = XOpenDisplay (display_name);
    if (dpy == NULL) {
      fprintf (stderr, "Can't open display %s\n", XDisplayName(display_name));
      exit (1);
    }
    if (screen < 0)
      screen = DefaultScreen (dpy);
    if (screen >= ScreenCount (dpy)) {
      fprintf (stderr, "Invalid screen number %d (display has %d)\n",
      	       screen, ScreenCount (dpy));
      exit (1);
    }

    root = RootWindow (dpy, screen);

    // get current resolution
    //
    sc = XRRGetScreenInfo (dpy, root);
    Rotation  current_rotation;
    SizeID    current_size;
    XRRScreenSize *sizes;
    int nsize;
    current_size = XRRConfigCurrentConfiguration (sc, &current_rotation);
    sizes = XRRConfigSizes(sc, &nsize);

    Handle<Object> resolution_object = Object::New(isolate);

    res = XRRGetScreenResourcesCurrent (dpy, root);
    for (int i=0; i<res->noutput; i++) {
        XRROutputInfo *output_info;

        output_info = XRRGetOutputInfo(dpy, res, res->outputs[i]);
        Handle<Object> output = Object::New(isolate);

        output->Set(String::NewFromUtf8(isolate, "name"),
                    String::NewFromUtf8(isolate, output_info->name));
        switch (output_info->connection) {
            case RR_Connected:
                output->Set(String::NewFromUtf8(isolate, "status"),
                            String::NewFromUtf8(isolate, "connected"));

                resolution_object->Set(String::NewFromUtf8(isolate, "width"),
                                      Integer::New(isolate, sizes[current_size].width));
                resolution_object->Set(String::NewFromUtf8(isolate, "height"),
                                      Integer::New(isolate, sizes[current_size].height));

                resolution_object->Set(String::NewFromUtf8(isolate, "mwidth"),
                                      Integer::New(isolate, sizes[current_size].mwidth));
                resolution_object->Set(String::NewFromUtf8(isolate, "mheight"),
                                      Integer::New(isolate, sizes[current_size].mheight));

                output->Set(String::NewFromUtf8(isolate, "resolution"), resolution_object);
                break;
            case RR_Disconnected:
                output->Set(String::NewFromUtf8(isolate, "status"), String::NewFromUtf8(isolate, "disconnected"));
                break;
        }

        Handle<Array> available_resolutions = Array::New(isolate);
        for (int j=0; j<output_info->nmode; j++) {
            char *resolution;
            XRRModeInfo *mode = find_mode_by_xid (output_info->modes[j], res);
            asprintf(&resolution, "%dx%d", mode->width, mode->height);
            available_resolutions->Set(j,String::NewFromUtf8(isolate, resolution));
        }
        output->Set(String::NewFromUtf8(isolate, "available_resolutions"),
                available_resolutions);

        result->Set(i,output);
    }

    info.GetReturnValue().Set(result);
}

NAN_METHOD(setScreenResolution) {
    Display *dpy;
    Isolate *isolate = info.GetIsolate();

    int width = info[0]->ToInteger()->Value();
    int height = info[1]->ToInteger()->Value();

    Rotation rotation = 1;
    int reflection = 0;

    char *displayname = NULL;

    dpy = XOpenDisplay (displayname);
    if (dpy == NULL) {
        printf ("Cannot open display %s\n", displayname);
        return info.GetReturnValue().Set(Boolean::New(isolate, False));
    }

    int screen = DefaultScreen (dpy);
    Window root = RootWindow (dpy, screen);
    int eventbase;
    int errorbase;
    if (!XRRQueryExtension(dpy, &eventbase, &errorbase)) {
        printf ("RandR extension missing\n");
        return info.GetReturnValue().Set(Boolean::New(isolate, False));
    }
    XRRScreenConfiguration *sc = XRRGetScreenInfo (dpy, root);
    if (sc == NULL) {
        printf ("Cannot get screen info\n");
        return info.GetReturnValue().Set(Boolean::New(isolate, False));
    }
    XSelectInput (dpy, root, StructureNotifyMask);
    XRRSelectInput (dpy, root, RRScreenChangeNotifyMask);

    Rotation current_rotation;
    SizeID current_size;
    current_size = XRRConfigCurrentConfiguration (sc, &current_rotation);

    int nsize;
    XRRScreenSize *sizes = XRRConfigSizes(sc, &nsize);
    SizeID sizeindex = 0;
    while (sizeindex < nsize) {
        if (sizes[sizeindex].width == width &&
        sizes[sizeindex].height == height)
            break;
        sizeindex++;
    }

    if (sizeindex >= nsize) {
        printf ("%dx%d resolution not available\n", width, height);
        XRRFreeScreenConfigInfo (sc);
        return info.GetReturnValue().Set(Boolean::New(isolate, False));
    }

    Status status = XRRSetScreenConfig (dpy, sc,
                                        DefaultRootWindow (dpy),
                                        sizeindex,
                                        (Rotation) (rotation | reflection),
                                        CurrentTime);
    if (status == RRSetConfigFailed) {
        printf ("Failed to change the screen resolution.\n");
        XRRFreeScreenConfigInfo (sc);
        return info.GetReturnValue().Set(Boolean::New(isolate, False));
    }
    else { // status == RRSetConfigSuccess
        if (sizeindex != current_size) {
            XEvent event;
            bool rcvdrrnotify = false;
            while (!rcvdrrnotify) {
                XNextEvent(dpy, (XEvent *) &event);
                //printf ("Event received, type = %d\n", event.type);
                XRRUpdateConfiguration (&event) ;
                switch (event.type - eventbase) {
                    case RRScreenChangeNotify:
                        rcvdrrnotify = true;
                        break;
                    default:
                        if (event.type != ConfigureNotify) {
                            printf("unknown event = %d!\n", event.type);
                        }
                        break;
                }
            }
        }
    }
    XRRFreeScreenConfigInfo (sc);
    info.GetReturnValue().Set(Boolean::New(isolate, True));
}

NAN_MODULE_INIT(init) {
    Nan::Set(target, New<String>("getDisplays").ToLocalChecked(),
        GetFunction(New<FunctionTemplate>(getDisplays)).ToLocalChecked());
    Nan::Set(target, New<String>("setScreenResolution").ToLocalChecked(),
        GetFunction(New<FunctionTemplate>(setScreenResolution)).ToLocalChecked());
}
NODE_MODULE(nodexrandr, init)
