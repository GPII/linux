/*
 * GPII Xrandr Bridge
 *
 * Copyright 2013 Emergya
 * Copyright 2015 Raising the Floor
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

#include <nan.h>

#include <stdio.h>
#include <iso646.h>
#include <X11/Xlib.h>
#include <X11/Xlibint.h>
#include <X11/Xproto.h>
#include <X11/Xatom.h>
#include <X11/extensions/Xrandr.h>
#include <X11/extensions/Xrender.h>
#include <strings.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#include <stdarg.h>
#include <math.h>

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

typedef enum _name_kind {
    name_none = 0,
    name_string = (1 << 0),
    name_xid = (1 << 1),
    name_index = (1 << 2),
    name_preferred = (1 << 3),
} name_kind_t;

typedef struct {
    name_kind_t	    kind;
    char    	    *string;
    XID	    	    xid;
    int		        index;
} name_t;

static void
init_name(name_t *name)
{
    name->kind = name_none;
}

static void
set_name_xid(name_t *name, XID xid)
{
    name->kind |= name_xid;
    name->xid = xid;
}

static double
mode_refresh(XRRModeInfo *mode_info)
{
    double rate;
    unsigned int vTotal = mode_info->vTotal;

    if (mode_info->modeFlags & RR_DoubleScan) {
        /* doublescan doubles the number of lines */
        vTotal *= 2;
    }

    if (mode_info->modeFlags & RR_Interlace) {
        /* interlace splits the frame into two fields */
        /* the field rate is what is typically reported by monitors */
        vTotal /= 2;
    }

    if (mode_info->hTotal && vTotal)
        rate = ((double) mode_info->dotClock /
                ((double) mode_info->hTotal * (double) vTotal));
    else
        rate = 0;
    return rate;
}

static XRRModeInfo *
find_mode(name_t *name, double refresh, XRRScreenResources *res)
{
    int m;
    XRRModeInfo *best = NULL;
    double bestDist = 0;

    for (m = 0; m < res->nmode; m++)
    {
	XRRModeInfo *mode = &res->modes[m];
        if ((name->kind & name_xid) && name->xid == mode->id)
        {
            best = mode;
            break;
        }
        if ((name->kind & name_string) && !strcmp(name->string, mode->name))
        {
            double dist;

            if (refresh)
                dist = fabs(mode_refresh(mode) - refresh);
            else
                dist = 0;
            if (!best || dist < bestDist)
            {
                bestDist = dist;
                best = mode;
            }
      	}
    }
    return best;
}

static XRRModeInfo *
find_mode_by_xid(RRMode mode, XRRScreenResources *res)
{
    name_t  mode_name;

    init_name(&mode_name);
    set_name_xid(&mode_name, mode);
    return find_mode(&mode_name, 0, res);
}

NAN_METHOD(getDisplays) {
    Display *dpy;
    char *display_name;
    int screen;
    char screenNumber[8];
    Window root;
    XRRScreenResources *res;
    XRRScreenConfiguration *sc;
    std::basic_string<char> errMsg;
    v8::Local<v8::Array> result = Nan::New<v8::Array>();

    // Get default display name.
    display_name = XDisplayName(NULL);
    dpy = XOpenDisplay(display_name);
    if (dpy == NULL) {
        errMsg.append("Can't open display ").append(display_name);
        Nan::ThrowError(errMsg.c_str());
    }
    screen = DefaultScreen(dpy);
    if (screen >= ScreenCount(dpy)) {
      sprintf(screenNumber, "%d", screen);
      errMsg.append("Invalid screen number (display has ").append(screenNumber).append(")");
      Nan::ThrowError(errMsg.c_str());
    }

    root = RootWindow(dpy, screen);

    // get current resolution
    //
    sc = XRRGetScreenInfo(dpy, root);
    Rotation  current_rotation;
    SizeID    current_size;
    XRRScreenSize *sizes;
    int nsize;
    current_size = XRRConfigCurrentConfiguration(sc, &current_rotation);
    sizes = XRRConfigSizes(sc, &nsize);

    v8::Local<v8::Object> resolution_object = Nan::New<v8::Object>();

    res = XRRGetScreenResourcesCurrent(dpy, root);
    for (int i=0; i<res->noutput; i++) {
        XRROutputInfo *output_info;

        output_info = XRRGetOutputInfo(dpy, res, res->outputs[i]);
        v8::Local<v8::Object> output = Nan::New<v8::Object>();

        output->Set(Nan::New("name").ToLocalChecked(),
                    Nan::New(output_info->name).ToLocalChecked());
        switch (output_info->connection) {
            case RR_Connected:
                output->Set(Nan::New("status").ToLocalChecked(),
                            Nan::New("connected").ToLocalChecked());

                resolution_object->Set(Nan::New("width").ToLocalChecked(),
                                       Nan::New(sizes[current_size].width));
                resolution_object->Set(Nan::New("height").ToLocalChecked(),
                                       Nan::New(sizes[current_size].height));

                resolution_object->Set(Nan::New("mwidth").ToLocalChecked(),
                                       Nan::New(sizes[current_size].mwidth));
                resolution_object->Set(Nan::New("mheight").ToLocalChecked(),
                                       Nan::New(sizes[current_size].mheight));

                output->Set(Nan::New("resolution").ToLocalChecked(), resolution_object);
                break;
            case RR_Disconnected:
                output->Set(Nan::New("status").ToLocalChecked(),
                            Nan::New("disconnected").ToLocalChecked());
                break;
        }

        v8::Local<v8::Array> available_resolutions = Nan::New<v8::Array>();
        for (int j=0; j<output_info->nmode; j++) {
            char *resolution;
            XRRModeInfo *mode = find_mode_by_xid(output_info->modes[j], res);
            asprintf(&resolution, "%dx%d", mode->width, mode->height);
            available_resolutions->Set(j, Nan::Encode(resolution,
                                                      strlen(resolution),
                                                      Nan::UTF8));
        }
        output->Set(Nan::New("available_resolutions").ToLocalChecked(),
                    available_resolutions);

        result->Set(i,output);
    }

    info.GetReturnValue().Set(result);
}

NAN_METHOD(setScreenResolution) {
    Display *dpy;

    int width = info[0]->ToInteger()->Value();
    int height = info[1]->ToInteger()->Value();

    Rotation rotation = 1;
    int reflection = 0;

    char *displayname = NULL;

    dpy = XOpenDisplay(displayname);
    if (dpy == NULL) {
        printf("Cannot open display %s\n", displayname);
        return info.GetReturnValue().Set(Nan::New(False));
    }

    int screen = DefaultScreen(dpy);
    Window root = RootWindow(dpy, screen);
    int eventbase;
    int errorbase;
    if (!XRRQueryExtension(dpy, &eventbase, &errorbase)) {
        printf("RandR extension missing\n");
        return info.GetReturnValue().Set(Nan::New(False));
    }
    XRRScreenConfiguration *sc = XRRGetScreenInfo(dpy, root);
    if (sc == NULL) {
        printf("Cannot get screen info\n");
        return info.GetReturnValue().Set(Nan::New(False));
    }
    XSelectInput(dpy, root, StructureNotifyMask);
    XRRSelectInput(dpy, root, RRScreenChangeNotifyMask);

    Rotation current_rotation;
    SizeID current_size;
    current_size = XRRConfigCurrentConfiguration(sc, &current_rotation);

    int nsize;
    XRRScreenSize *sizes = XRRConfigSizes(sc, &nsize);
    SizeID sizeindex = 0;
    while (sizeindex < nsize) {
        if (sizes[sizeindex].width == width &&
        sizes[sizeindex].height == height)
            break;
        sizeindex++;
    }

    if (sizeindex >= nsize) {
        printf("%dx%d resolution not available\n", width, height);
        XRRFreeScreenConfigInfo(sc);
        return info.GetReturnValue().Set(Nan::New(False));
    }

    Status status = XRRSetScreenConfig(dpy, sc,
                                       DefaultRootWindow(dpy),
                                       sizeindex,
                                       (Rotation) (rotation | reflection),
                                       CurrentTime);
    if (status == RRSetConfigFailed) {
        printf("Failed to change the screen resolution.\n");
        XRRFreeScreenConfigInfo(sc);
        return info.GetReturnValue().Set(Nan::New(False));
    }
    else { // status == RRSetConfigSuccess
        if (sizeindex != current_size) {
            XEvent event;
            bool rcvdrrnotify = false;
            while (!rcvdrrnotify) {
                XNextEvent(dpy, (XEvent *) &event);
                //printf("Event received, type = %d\n", event.type);
                XRRUpdateConfiguration(&event) ;
                switch (event.type - eventbase) {
                    case RRScreenChangeNotify:
                        rcvdrrnotify = true;
                        break;
                    default:
                        if (event.type != ConfigureNotify) {
                            printf("unknown event = %d!\n", event.type);
                        }
                        break;
                }
            }
        }
    }
    XRRFreeScreenConfigInfo(sc);
    info.GetReturnValue().Set(Nan::New(True));
}

NAN_MODULE_INIT(init) {
    Nan::Set(target, Nan::New<v8::String>("getDisplays").ToLocalChecked(),
        Nan::GetFunction(Nan::New<v8::FunctionTemplate>(getDisplays)).ToLocalChecked());
    Nan::Set(target, Nan::New<v8::String>("setScreenResolution").ToLocalChecked(),
        Nan::GetFunction(Nan::New<v8::FunctionTemplate>(setScreenResolution)).ToLocalChecked());
}
NODE_MODULE(nodexrandr, init)
