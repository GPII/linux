/*
GPII Node.js PackageKit Bridge

Copyright 2012 Steven Githens
Copyright 2013 Emergya

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/
#define I_KNOW_THE_PACKAGEKIT_GLIB2_API_IS_SUBJECT_TO_CHANGE 1

#include <node.h>
#include <v8.h>
#include <packagekit-glib2/packagekit.h>
#include <gio/gio.h>
#include <json-glib/json-glib.h>

using namespace v8;

/**
 * searchPackage:
 *
 * Should take as arguments:
 *   name: Name of the package, aka: search criteria (str)
 * Returns: Array of packages matching the search criteria
 */
Handle<Value> searchPackage(const Arguments& args) {
  HandleScope scope;
  PkClient *client = NULL;
  PkResults *results = NULL;
  GPtrArray *array;
  PkPackageSack *sack = NULL;
  char name[1024];
  args[0]->ToString()->WriteAscii(name);
  gchar *names[] = {name};
  GError *err = NULL;
  v8::Handle<v8::Array> result = v8::Array::New();

  client = pk_client_new();
  results = pk_client_search_names(client, PK_INFO_ENUM_INSTALLED | 
                                   PK_INFO_ENUM_AVAILABLE, names,
                                   NULL, NULL, NULL, &err);

  sack = pk_results_get_package_sack(results);
  pk_package_sack_sort(sack, PK_PACKAGE_SACK_SORT_TYPE_NAME);
  array = pk_package_sack_get_array(sack);

  for (unsigned int i=0; i<array->len; i++) {
    PkPackage *package = (PkPackage *) g_ptr_array_index(array, i);

    v8::Handle<v8::Object> pac = v8::Object::New();
    pac->Set(String::New("id"), String::New(pk_package_get_id(package)));
    pac->Set(String::New("name"), String::New(pk_package_get_name(package)));
    pac->Set(String::New("version"),
             String::New(pk_package_get_version(package)));
    pac->Set(String::New("data"), String::New(pk_package_get_data(package)));

    result->Set(i,pac);
  }

  if (results != NULL)
                g_object_unref (results);
  if (sack != NULL)
                g_object_unref (sack);

  return scope.Close(result);
}

/**
 * installPackage:
 *
 * Should take as arguments:
 *   name: Name of the package (str)
 * Returns: true | false (bool)
 */
Handle<Value> installPackage(const Arguments& args) {
  HandleScope scope;
  PkTask *task;
  GError *err = NULL;
  char name[1024];
  args[0]->ToString()->WriteUtf8(name);
  gchar **package_ids = NULL;

  task = pk_task_new();
  package_ids = pk_package_ids_from_id (name);
  pk_task_install_packages_sync(task, package_ids, NULL, NULL, NULL, &err);

  g_strfreev (package_ids);
  
 
  return scope.Close(String::New("'installPackage' dummy method"));
}

/**
 * removePackage:
 *
 * Should take as arguments:
 *   name: Name of the package (str)
 * Returns: true | false (bool)
 */
Handle<Value> removePackage(const Arguments& args) {
  HandleScope scope;
  PkTask *task;
  GError *err = NULL;
  char name[1024];
  args[0]->ToString()->WriteUtf8(name);
  gchar **package_ids = NULL;

  task = pk_task_new();
  package_ids = pk_package_ids_from_id (name);
  pk_task_remove_packages_sync(task, package_ids, TRUE, FALSE, NULL, NULL, NULL, &err);

  g_strfreev (package_ids);
 
  return scope.Close(String::New("'removePackage' dummy method"));
}

void init(Handle<Object> target) {
  g_type_init(); // Initialize gobject system
  target->Set(String::NewSymbol("searchPackage"),
              FunctionTemplate::New(searchPackage)->GetFunction());
  target->Set(String::NewSymbol("installPackage"),
              FunctionTemplate::New(installPackage)->GetFunction());
  target->Set(String::NewSymbol("removePackage"),
              FunctionTemplate::New(removePackage)->GetFunction());
}
NODE_MODULE(nodepackagekit, init)

