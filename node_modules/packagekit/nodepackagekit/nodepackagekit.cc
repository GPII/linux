/*
GPII Node.js PackageKit Bridge

Copyright 2012 Steven Githens
Copyright 2013 Emergya
Copyright 2013, 2014 Inclusive Design Research Centre, OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/
#define I_KNOW_THE_PACKAGEKIT_GLIB2_API_IS_SUBJECT_TO_CHANGE 1

#include <string.h>
#include <node.h>
#include <v8.h>
#include <packagekit-glib2/packagekit.h>
#include <gio/gio.h>
#include <json-glib/json-glib.h>

using namespace v8;

/* Set DEBUG to TRUE in order to see the transactions' progress
 * TODO: Allow switching DEBUG value from Node.js side
 */
static gboolean DEBUG = FALSE;

static gchar TAG[] = "[nodePackagekit]";

static void
progressCallback(PkProgress *progress, PkProgressType type) {
  if (!DEBUG) return;
  PkStatusEnum status;
  gint percentage;
  gboolean allow_cancel;

  g_object_get(progress,
               "status", &status,
               "percentage", &percentage,
               "allow-cancel", &allow_cancel,
               NULL);

  if (type == PK_PROGRESS_TYPE_STATUS) {
    printf ("%s Transaction status: %s\n", TAG, pk_status_enum_to_string (status));
  } else if (type == PK_PROGRESS_TYPE_PERCENTAGE) {
    if (percentage > 0)
      printf ("%s Current percentage: %d%%\n", TAG, percentage);
  }
}

static PkBitfield
handleFiltersArgument (const Arguments& args, const int filterIndex) {
  char filters[256];

  if (args.Length() > filterIndex) {
    args[filterIndex]->ToString()->WriteUtf8 (filters);
  }
  else {
    strcpy (filters, "none");
  }
  return pk_filter_bitfield_from_string (filters);
}

/**
 * searchPackage:
 *
 * Should take as arguments:
 *   name:    Name of the package, aka: search criteria (str)
 *   filters: Filters for the search as a string, e.g. "~devel;basename".  See:
 *            http://www.packagekit.org/gtk-doc/introduction-ideas-filters.html
 *            Special case:  the "none" filter = installed or available.
 * Returns: Array of packages matching the search criteria
 */
Handle<Value> searchPackage(const Arguments& args) {
  HandleScope scope;
  PkClient *client = NULL;
  PkResults *results = NULL;
  GPtrArray *array;
  PkPackageSack *sack = NULL;
  char name[1024];
  PkBitfield filtersBitField;
  GError *err = NULL;
  v8::Handle<v8::Array> result = v8::Array::New();

  args[0]->ToString()->WriteUtf8(name);
  gchar *names[sizeof(name)] = {name};

  filtersBitField = handleFiltersArgument (args, 1);

  client = pk_client_new();
  results = pk_client_search_names (client, filtersBitField,
                                    names, NULL,
                                    (PkProgressCallback) progressCallback, NULL, &err);

  sack = pk_results_get_package_sack(results);
  pk_package_sack_sort(sack, PK_PACKAGE_SACK_SORT_TYPE_NAME);
  array = pk_package_sack_get_array(sack);

  for (unsigned int i=0; i<array->len; i++) {
    PkPackage *package = (PkPackage *) g_ptr_array_index(array, i);

    v8::Handle<v8::Object> pac = v8::Object::New();
    pac->Set(String::New("id"), String::New(pk_package_get_id(package)));
    pac->Set(String::New("name"), String::New(pk_package_get_name(package)));
    pac->Set(String::New("version"),
             String::New(pk_package_get_version(package)));
    pac->Set(String::New("data"), String::New(pk_package_get_data(package)));

    result->Set(i,pac);
  }

  if (results != NULL)
    g_object_unref (results);
  if (sack != NULL)
    g_object_unref (sack);
  if (client != NULL)
    g_object_unref (client);

  return scope.Close(result);
}

/**
 * searchFiles:
 *
 * Should take as arguments:
 *   name:    Path name associated with package, e.g., "/usr/bin/orca".
 *   filters: Filters for the search as a string, e.g. "~devel;basename".  See:
 *            http://www.packagekit.org/gtk-doc/introduction-ideas-filters.html
 *            Special case:  the "none" filter = installed or available.
 * Returns: Array of packages matching the search criteria.
 */
Handle<Value> searchFiles (const Arguments& args) {
  HandleScope scope;
  PkClient *client = NULL;
  PkResults *results = NULL;
  GPtrArray *array;
  PkPackageSack *sack = NULL;
  char pathName[1024];
  PkBitfield filtersBitField;
  GError *err = NULL;
  v8::Handle<v8::Array> result = v8::Array::New();

  args[0]->ToString()->WriteUtf8(pathName);
  gchar *pathNames[sizeof(pathName)] = {pathName};
  filtersBitField = handleFiltersArgument (args, 1);

  client = pk_client_new();
  results = pk_client_search_files (client, filtersBitField,
                                    pathNames, NULL,
                                    (PkProgressCallback) progressCallback, NULL, &err);

  sack = pk_results_get_package_sack(results);
  pk_package_sack_sort(sack, PK_PACKAGE_SACK_SORT_TYPE_NAME);
  array = pk_package_sack_get_array(sack);

  for (unsigned int i=0; i<array->len; i++) {
    PkPackage *package = (PkPackage *) g_ptr_array_index(array, i);

    v8::Handle<v8::Object> pac = v8::Object::New();
    pac->Set(String::New("id"), String::New(pk_package_get_id(package)));
    pac->Set(String::New("name"), String::New(pk_package_get_name(package)));
    pac->Set(String::New("version"),
             String::New(pk_package_get_version(package)));
    pac->Set(String::New("data"), String::New(pk_package_get_data(package)));

    result->Set(i,pac);
  }

  if (results != NULL)
    g_object_unref (results);
  if (sack != NULL)
    g_object_unref (sack);
  if (client != NULL)
    g_object_unref (client);

  return scope.Close(result);
}

/**
 * getPackages:
 *
 * Should take as arguments:
 *   filters: Filters for list of packages to return, e.g. "installed" or
 *            "~installed", or "~devel;basename".
 *            See:
 *            http://www.packagekit.org/gtk-doc/introduction-ideas-filters.html
 *            Special case:  the "none" filter = installed or available, which
 *            means every possible package.  If no argument is passed, this
 *            assumes the "none" filter.
 * Returns: Array of packages matching the filters.
 */
Handle<Value> getPackages(const Arguments& args) {
  HandleScope scope;
  PkClient *client = NULL;
  PkResults *results = NULL;
  GPtrArray *array;
  PkPackageSack *sack = NULL;
  PkBitfield filtersBitField;
  GError *err = NULL;
  v8::Handle<v8::Array> result = v8::Array::New();

  filtersBitField = handleFiltersArgument (args, 0);
  client = pk_client_new();
  results = pk_client_get_packages (client, filtersBitField,
                                    NULL, (PkProgressCallback) progressCallback,
                                    NULL, &err);

  sack = pk_results_get_package_sack(results);
  pk_package_sack_sort(sack, PK_PACKAGE_SACK_SORT_TYPE_NAME);
  array = pk_package_sack_get_array(sack);

  for (unsigned int i=0; i<array->len; i++) {
    PkPackage *package = (PkPackage *) g_ptr_array_index(array, i);

    v8::Handle<v8::Object> pac = v8::Object::New();
    pac->Set(String::New("id"), String::New(pk_package_get_id(package)));
    pac->Set(String::New("name"), String::New(pk_package_get_name(package)));
    pac->Set(String::New("version"),
             String::New(pk_package_get_version(package)));
    pac->Set(String::New("data"), String::New(pk_package_get_data(package)));

    result->Set(i,pac);
  }

  if (results != NULL)
    g_object_unref (results);
  if (sack != NULL)
    g_object_unref (sack);
  if (client != NULL)
    g_object_unref (client);

  return scope.Close(result);
}

/**
 * installPackage:
 *
 * Should take as arguments:
 *   name: The package id (str).
 * Returns: true | false (bool)
 */
Handle<Value> installPackage(const Arguments& args) {
  HandleScope scope;
  PkTask *task;
  GError *err = NULL;
  char name[1024];
  args[0]->ToString()->WriteUtf8(name);
  gchar **package_ids = NULL;

  task = pk_task_new();
  package_ids = pk_package_ids_from_id (name);

  pk_task_install_packages_sync(task, package_ids, NULL,
                                (PkProgressCallback) progressCallback,
                                NULL, &err);

  g_strfreev (package_ids);

  return scope.Close(True());
}

/**
 * updatePackage:
 *
 * Should take as arguments:
 *   name: The package id (str).
 * Returns: true | false (bool)
 */
Handle<Value> updatePackage(const Arguments& args) {
  HandleScope scope;
  PkTask *task;
  GError *err = NULL;
  char name[1024];
  args[0]->ToString()->WriteUtf8(name);
  gchar **package_ids = NULL;

  task = pk_task_new();
  package_ids = pk_package_ids_from_id (name);

  pk_task_update_packages_sync (task, package_ids, NULL,
                               (PkProgressCallback) progressCallback,
                               NULL, &err);

  g_strfreev (package_ids);

  return scope.Close(True());
}

/**
 * removePackage:
 *
 * Should take as arguments:
 *   name: Name of the package (str)
 * Returns: true | false (bool)
 */
Handle<Value> removePackage(const Arguments& args) {
  HandleScope scope;
  PkTask *task;
  GError *err = NULL;
  char name[1024];
  args[0]->ToString()->WriteUtf8(name);
  gchar **package_ids = NULL;

  task = pk_task_new();
  package_ids = pk_package_ids_from_id (name);

  pk_task_remove_packages_sync(task, package_ids, TRUE, FALSE, NULL,
                               (PkProgressCallback) progressCallback,
                               NULL, &err);

  g_strfreev (package_ids);

  return scope.Close(True());
}

void init(Handle<Object> target) {
  target->Set(String::NewSymbol("searchPackage"),
              FunctionTemplate::New(searchPackage)->GetFunction());
  target->Set(String::NewSymbol("searchFiles"),
              FunctionTemplate::New(searchFiles)->GetFunction());
  target->Set(String::NewSymbol("getPackages"),
              FunctionTemplate::New(getPackages)->GetFunction());
  target->Set(String::NewSymbol("installPackage"),
              FunctionTemplate::New(installPackage)->GetFunction());
  target->Set(String::NewSymbol("updatePackage"),
              FunctionTemplate::New(installPackage)->GetFunction());
  target->Set(String::NewSymbol("removePackage"),
              FunctionTemplate::New(removePackage)->GetFunction());
}
NODE_MODULE(nodepackagekit, init)

